// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
	io "io"

	massifs "github.com/datatrails/go-datatrails-merklelog/massifs"
	mock "github.com/stretchr/testify/mock"
)

// DirCache is an autogenerated mock type for the DirCache type
type DirCache struct {
	mock.Mock
}

// DeleteEntry provides a mock function with given fields: directory
func (_m *DirCache) DeleteEntry(directory string) {
	_m.Called(directory)
}

// FindMassifFiles provides a mock function with given fields: directory
func (_m *DirCache) FindMassifFiles(directory string) error {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for FindMassifFiles")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(directory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetEntry provides a mock function with given fields: directory
func (_m *DirCache) GetEntry(directory string) (massifs.DirCacheEntry, bool) {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for GetEntry")
	}

	var r0 massifs.DirCacheEntry
	var r1 bool
	if rf, ok := ret.Get(0).(func(string) (massifs.DirCacheEntry, bool)); ok {
		return rf(directory)
	}
	if rf, ok := ret.Get(0).(func(string) massifs.DirCacheEntry); ok {
		r0 = rf(directory)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(massifs.DirCacheEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(directory)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GetOpener provides a mock function with no fields
func (_m *DirCache) GetOpener() massifs.Opener {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetOpener")
	}

	var r0 massifs.Opener
	if rf, ok := ret.Get(0).(func() massifs.Opener); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(massifs.Opener)
		}
	}

	return r0
}

// Open provides a mock function with given fields: fileName
func (_m *DirCache) Open(fileName string) (io.ReadCloser, error) {
	ret := _m.Called(fileName)

	if len(ret) == 0 {
		panic("no return value specified for Open")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (io.ReadCloser, error)); ok {
		return rf(fileName)
	}
	if rf, ok := ret.Get(0).(func(string) io.ReadCloser); ok {
		r0 = rf(fileName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(fileName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with no fields
func (_m *DirCache) Options() massifs.DirCacheOptions {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 massifs.DirCacheOptions
	if rf, ok := ret.Get(0).(func() massifs.DirCacheOptions); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(massifs.DirCacheOptions)
	}

	return r0
}

// ReadMassif provides a mock function with given fields: directory, massifIndex
func (_m *DirCache) ReadMassif(directory string, massifIndex uint64) (*massifs.MassifContext, error) {
	ret := _m.Called(directory, massifIndex)

	if len(ret) == 0 {
		panic("no return value specified for ReadMassif")
	}

	var r0 *massifs.MassifContext
	var r1 error
	if rf, ok := ret.Get(0).(func(string, uint64) (*massifs.MassifContext, error)); ok {
		return rf(directory, massifIndex)
	}
	if rf, ok := ret.Get(0).(func(string, uint64) *massifs.MassifContext); ok {
		r0 = rf(directory, massifIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*massifs.MassifContext)
		}
	}

	if rf, ok := ret.Get(1).(func(string, uint64) error); ok {
		r1 = rf(directory, massifIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadMassifDirEntry provides a mock function with given fields: directory
func (_m *DirCache) ReadMassifDirEntry(directory string) (massifs.DirCacheEntry, error) {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for ReadMassifDirEntry")
	}

	var r0 massifs.DirCacheEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (massifs.DirCacheEntry, error)); ok {
		return rf(directory)
	}
	if rf, ok := ret.Get(0).(func(string) massifs.DirCacheEntry); ok {
		r0 = rf(directory)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(massifs.DirCacheEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(directory)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadMassifStart provides a mock function with given fields: filepath
func (_m *DirCache) ReadMassifStart(filepath string) (massifs.MassifStart, string, error) {
	ret := _m.Called(filepath)

	if len(ret) == 0 {
		panic("no return value specified for ReadMassifStart")
	}

	var r0 massifs.MassifStart
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(string) (massifs.MassifStart, string, error)); ok {
		return rf(filepath)
	}
	if rf, ok := ret.Get(0).(func(string) massifs.MassifStart); ok {
		r0 = rf(filepath)
	} else {
		r0 = ret.Get(0).(massifs.MassifStart)
	}

	if rf, ok := ret.Get(1).(func(string) string); ok {
		r1 = rf(filepath)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string) error); ok {
		r2 = rf(filepath)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ReadSeal provides a mock function with given fields: directory, massifIndex
func (_m *DirCache) ReadSeal(directory string, massifIndex uint64) (*massifs.SealedState, error) {
	ret := _m.Called(directory, massifIndex)

	if len(ret) == 0 {
		panic("no return value specified for ReadSeal")
	}

	var r0 *massifs.SealedState
	var r1 error
	if rf, ok := ret.Get(0).(func(string, uint64) (*massifs.SealedState, error)); ok {
		return rf(directory, massifIndex)
	}
	if rf, ok := ret.Get(0).(func(string, uint64) *massifs.SealedState); ok {
		r0 = rf(directory, massifIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*massifs.SealedState)
		}
	}

	if rf, ok := ret.Get(1).(func(string, uint64) error); ok {
		r1 = rf(directory, massifIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadSealDirEntry provides a mock function with given fields: directory
func (_m *DirCache) ReadSealDirEntry(directory string) (massifs.DirCacheEntry, error) {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for ReadSealDirEntry")
	}

	var r0 massifs.DirCacheEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (massifs.DirCacheEntry, error)); ok {
		return rf(directory)
	}
	if rf, ok := ret.Get(0).(func(string) massifs.DirCacheEntry); ok {
		r0 = rf(directory)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(massifs.DirCacheEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(directory)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceMassif provides a mock function with given fields: logfile, mc
func (_m *DirCache) ReplaceMassif(logfile string, mc *massifs.MassifContext) error {
	ret := _m.Called(logfile, mc)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceMassif")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *massifs.MassifContext) error); ok {
		r0 = rf(logfile, mc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReplaceSeal provides a mock function with given fields: sealFilename, massifIndex, sealedState
func (_m *DirCache) ReplaceSeal(sealFilename string, massifIndex uint32, sealedState *massifs.SealedState) error {
	ret := _m.Called(sealFilename, massifIndex, sealedState)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceSeal")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint32, *massifs.SealedState) error); ok {
		r0 = rf(sealFilename, massifIndex, sealedState)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResolveMassifDir provides a mock function with given fields: tenantIdentityOrLocalPath
func (_m *DirCache) ResolveMassifDir(tenantIdentityOrLocalPath string) (string, error) {
	ret := _m.Called(tenantIdentityOrLocalPath)

	if len(ret) == 0 {
		panic("no return value specified for ResolveMassifDir")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(tenantIdentityOrLocalPath)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(tenantIdentityOrLocalPath)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(tenantIdentityOrLocalPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolveSealDir provides a mock function with given fields: tenantIdentityOrLocalPath
func (_m *DirCache) ResolveSealDir(tenantIdentityOrLocalPath string) (string, error) {
	ret := _m.Called(tenantIdentityOrLocalPath)

	if len(ret) == 0 {
		panic("no return value specified for ResolveSealDir")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(tenantIdentityOrLocalPath)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(tenantIdentityOrLocalPath)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(tenantIdentityOrLocalPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewDirCache creates a new instance of DirCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDirCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *DirCache {
	mock := &DirCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
